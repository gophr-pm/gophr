#! /bin/bash

SEMVER_REGEX="^(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)(\-[0-9A-Za-z-]+(\.[0-9A-Za-z-]+)*)?(\+[0-9A-Za-z-]+(\.[0-9A-Za-z-]+)*)?$"

function validate-version {
  local version=$1
  if [[ "$version" =~ $SEMVER_REGEX ]]; then
    # if a second argument is passed, store the result in var named by $2
    if [ "$#" -eq "2" ]; then
      local major=${BASH_REMATCH[1]}
      local minor=${BASH_REMATCH[2]}
      local patch=${BASH_REMATCH[3]}
      local prere=${BASH_REMATCH[4]}
      local build=${BASH_REMATCH[5]}
      eval "$2=(\"$major\" \"$minor\" \"$patch\" \"$prere\" \"$build\")"
    else
      echo "$version"
    fi
  else
    echo "version $version does not match the semver scheme 'X.Y.Z(-PRERELEASE)(+BUILD)'. See help for more information."
    exit 2
  fi
}

function command-bump {
  local new; local pretend=0; local version=$1; local segment=$2; local prerellabel=$3;
  while [[ $# -gt 0 ]]; do
    validate-version $version split
    local major=${split[0]}
    local minor=${split[1]}
    local patch=${split[2]}
    local prere=${split[3]}
    local build=${split[4]}

    case "$segment" in
      major) new="$(($major + 1)).0.0"; shift ;;
      minor) new="${major}.$(($minor + 1)).0"; shift ;;
      patch) new="${major}.${minor}.$(($patch + 1))"; shift ;;
      prerel)
        new=$(validate-version "${major}.${minor}.${patch}-${prerellabel}") ;;
      build)
        new=$(validate-version "${major}.${minor}.${patch}${prere}+${2}") ;;
      *) exit 1 ;;
    esac
  done

  echo $new
}

command-bump $1 $2 $3
exit 0
